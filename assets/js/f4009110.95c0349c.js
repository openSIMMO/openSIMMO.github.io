"use strict";(self.webpackChunkopenSIMMO=self.webpackChunkopenSIMMO||[]).push([[816],{5890:(n,e,a)=>{a.r(e),a.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>f,frontMatter:()=>i,metadata:()=>d,toc:()=>s});var t=a(4848),o=a(8453);const i={id:"05_01_Orderselection",title:"Compute the necesary diffraction orders on the DMD"},r=void 0,d={id:"05_01_Orderselection",title:"Compute the necesary diffraction orders on the DMD",description:"",source:"@site/docs/05_01_Orderselection.mdx",sourceDirName:".",slug:"/05_01_Orderselection",permalink:"/docs/05_01_Orderselection",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{id:"05_01_Orderselection",title:"Compute the necesary diffraction orders on the DMD"},sidebar:"tutorialSidebar",previous:{title:"Reconstruction",permalink:"/docs/34"},next:{title:"Computing SIM Patterns",permalink:"/docs/05_02_PatternComputation"}},l={},s=[];function _(n){const e={code:"code",img:"img",p:"p",pre:"pre",...(0,o.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'# to display plot in notebook\n# to display plot in interactive window\n#%matplotlib\nfrom collections.abc import Sequence\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import PowerNorm\nfrom matplotlib.widgets import Slider, TextBox\nimport numpy as np\nimport mcsim.analysis.simulate_dmd as sdmd\n\n\ndef display_2d(dmd: sdmd.DMD,\n               figsize: Sequence[float, float] = (8., 6.),\n               cmap: str = "OrRd",\n               axcolor: str = "lightgoldenrodyellow",\n               n_max_order: int = 20):\n    """\n    Create manipulatable plot to explore DMD diffraction for different input angles in several colors\n\n    :param dmd: DMD class object\n    :param figsize: (size_x, size_y)\n    :param cmap: name of matplotlib colormap\n    :param axcolor: name of matplotlib color to use when displaying axes\n    :param n_max_order: maximum diffraction order to plot\n    :return:\n    """\n\n    # find zero orders for later\n    # diffraction orders to simulate\n    dx, dy = np.meshgrid(np.arange(-n_max_order, n_max_order, dtype=int),\n                         np.arange(-n_max_order, n_max_order, dtype=int))\n    zero_order = np.where(np.logical_and(dx == 0, dy == 0))\n\n    # turn interactive mode off, or have problems with plot freezing\n    plt.ioff()\n\n    # plot showing diffraction orders for each input angle, with a moveable slider\n    figh = plt.figure(figsize=figsize)\n\n    ncols_half = 4\n    grid = figh.add_gridspec(nrows=8,  # define rows\n                             height_ratios=[1] + [0.1] + [0.075] * 6,\n                             hspace=0.2,\n                             bottom=0.02, top=0.8,\n                             ncols=ncols_half * 2 + 1,  # define columns\n                             wspace=2,\n                             width_ratios=[1] * ncols_half + [0.5] + [1] * ncols_half,\n                             left=0.1, right=0.9)\n\n    # #####################\n    # create axes\n    # #####################\n\n    # main plots\n    tics = [-1., -0.5, 0.0, 0.5, 1.]\n    ax_on = figh.add_subplot(grid[0, :ncols_half])\n    ax_off = figh.add_subplot(grid[0, ncols_half + 1:])\n\n    # other plots\n    dm_axis = figh.add_subplot(grid[-1, 0:2], facecolor=axcolor)\n    wlen_axis = figh.add_subplot(grid[-1, 3:5], facecolor=axcolor)\n    slider_axes_x = figh.add_subplot(grid[-2, 1:-1], facecolor=axcolor)\n    slider_axes_y = figh.add_subplot(grid[-3, 1:-1], facecolor=axcolor)\n    slider_axis_t2 = figh.add_subplot(grid[-6, ncols_half + 1:], facecolor=axcolor)\n    slider_axis_phi2 = figh.add_subplot(grid[-5, ncols_half + 1:], facecolor=axcolor)\n    slider_axis_theta2 = figh.add_subplot(grid[-4, ncols_half + 1:], facecolor=axcolor)\n    slider_axis_t1 = figh.add_subplot(grid[-6, :ncols_half], facecolor=axcolor)\n    slider_axis_phi1 = figh.add_subplot(grid[-5, :ncols_half], facecolor=axcolor)\n    slider_axis_theta1 = figh.add_subplot(grid[-4, :ncols_half], facecolor=axcolor)\n\n    # start values\n    g1_start = dmd.gamma_on * 180/np.pi\n    theta1_start = np.arccos(dmd.rot_axis_on[2]) * 180 / np.pi\n    phi1_start = np.arctan2(dmd.rot_axis_on[1],\n                            dmd.rot_axis_on[0]) * 180 / np.pi\n\n    g2_start = dmd.gamma_off * 180/np.pi\n    theta2_start = np.arccos(dmd.rot_axis_off[2]) * 180 / np.pi\n    phi2_start = np.arctan2(dmd.rot_axis_off[1],\n                            dmd.rot_axis_off[0]) * 180 / np.pi\n\n    # create sliders\n    slider_x = Slider(slider_axes_x,\n                      \'Input direction $a_x$\',\n                      -1, 1, valinit=0, valstep=0.005)\n    slider_y = Slider(slider_axes_y,\n                      \'Input direction $a_y$\',\n                      -1, 1, valinit=0, valstep=0.005)\n    slider_t1 = Slider(slider_axis_t1,\n                       r\'$\\gamma_+$ (deg)\',\n                       -20,\n                       20,\n                       valinit=g1_start,\n                       valstep=0.1)\n\n    slider_phi1 = Slider(slider_axis_phi1,\n                         r"$\\phi_+$ (deg)",\n                         -180, 180,\n                         valinit=phi1_start,\n                         valstep=0.1)\n\n    slider_theta1 = Slider(slider_axis_theta1,\n                           r"$\\theta_+$ (deg)",\n                           0, 180,\n                           valinit=theta1_start,\n                           valstep=0.1)\n\n    slider_t2 = Slider(slider_axis_t2,\n                       r\'$\\gamma_-$ (deg)\',\n                       -20,\n                       20,\n                       valinit=g2_start,\n                       valstep=0.1)\n\n    slider_phi2 = Slider(slider_axis_phi2,\n                         r"$\\phi_-$ (deg)",\n                         -180, 180,\n                         valinit=phi2_start,\n                         valstep=0.1)\n\n    slider_theta2 = Slider(slider_axis_theta2,\n                           r"$\\theta_-$ (deg)",\n                           0, 180,\n                           valinit=theta2_start,\n                           valstep=0.1)\n\n    dm_box = TextBox(dm_axis, label="pitch ($\\mu$m)", initial=str(dmd.dx))\n    wlen_box = TextBox(wlen_axis, label="$\\lambda$ ($\\mu$m)", initial=str(dmd.wavelength))\n\n    def update_dm(val):\n        dmd.dx = float(val)\n        dmd.dy = float(val)\n        update()\n\n    def update_wl(val):\n        dmd.wavelength = float(val)\n        update()\n\n    # function called when sliders are moved on plot\n    def update(val=None):\n        ax_on.clear()\n        ax_off.clear()\n\n        # get input direction from sliders\n        ax_in = slider_x.val\n        ay_in = slider_y.val\n        az_in = -np.sqrt(1 - ax_in**2 - ay_in**2)\n        a_vec = np.stack((ax_in, ay_in, az_in), axis=0)\n\n        # define composite rotations for DMD\n        dmd.gamma_on = float(slider_t1.val * np.pi/180)\n        dmd.gamma_off = float(slider_t2.val * np.pi/180)\n\n        theta1 = float(slider_theta1.val * np.pi/180)\n        phi1 = float(slider_phi1.val * np.pi/180)\n        dmd.rot_axis_on = np.array([np.cos(phi1) * np.sin(theta1),\n                                    np.sin(phi1) * np.sin(theta1),\n                                    np.cos(theta1)])\n\n        theta2 = float(slider_theta2.val * np.pi / 180)\n        phi2 = float(slider_phi2.val * np.pi / 180)\n        dmd.rot_axis_off = np.array([np.cos(phi2) * np.sin(theta2),\n                                     np.sin(phi2) * np.sin(theta2),\n                                     np.cos(theta2)])\n\n        # diffraction info\n        b_all_diff = sdmd.solve_diffraction_output(a_vec,\n                                                   dmd.dx,\n                                                   dmd.dy,\n                                                   dmd.wavelength,\n                                                   dx,\n                                                   dy)\n        all_diff_int_on = sdmd.blaze_envelope(dmd.wavelength,\n                                              dmd.gamma_on,\n                                              dmd.wx,\n                                              dmd.wy,\n                                              b_all_diff - a_vec,\n                                              dmd.rot_axis_on) ** 2\n        all_diff_int_off = sdmd.blaze_envelope(dmd.wavelength,\n                                               dmd.gamma_off,\n                                               dmd.wx,\n                                               dmd.wy,\n                                               b_all_diff - a_vec,\n                                               dmd.rot_axis_off) ** 2\n        # blaze conditions\n        b_on_out = sdmd.solve_blaze_output(a_vec, dmd.gamma_on, dmd.rot_axis_on)\n        b_off_out = sdmd.solve_blaze_output(a_vec, dmd.gamma_off, dmd.rot_axis_off)\n\n        #\n        figh.suptitle("DMD diffraction solution explorer\\n"\n                      f"Input direction $a$ = ({a_vec[0]:.3f}, "\n                       f"{a_vec[1]:.3f}, "\n                       f"{a_vec[2]:.3f})")\n\n        # #####################################\n        # on-mirrors plot\n        # #####################################\n        im = ax_on.scatter(b_all_diff[..., 0].ravel(),\n                           b_all_diff[..., 1].ravel(),\n                           c=all_diff_int_on.ravel(),\n                           cmap=cmap,\n                           norm=PowerNorm(vmin=0, vmax=1, gamma=0.2))\n\n        # zero diffraction order\n        ax_on.plot(b_all_diff[..., 0][zero_order],\n                   b_all_diff[..., 1][zero_order],\n                   \'mx\',\n                   label="0th order")\n\n        # blaze angle out\n        ax_on.plot(b_on_out[:, 0],\n                   b_on_out[:, 1],\n                   \'kx\',\n                   label="blaze")\n\n        ax_on.set_xlabel(\'$b_x$\')\n        ax_on.set_ylabel(\'$b_y$\')\n        ax_on.axis("equal")\n        ax_on.set_xlim([-1, 1])\n        ax_on.set_ylim([-1, 1])\n        ax_on.set_title("\'+\' mirrors\\n"\n                        f"rot axis = ({dmd.rot_axis_on[0]:.3f}, "\n                        f"{dmd.rot_axis_on[1]:.3f}, "\n                        f"{dmd.rot_axis_on[2]:.3f})")\n\n        ax_on.set_xticks(tics)\n        ax_on.set_yticks(tics)\n\n        # #####################################\n        # off-mirrors plot\n        # #####################################\n        im = ax_off.scatter(b_all_diff[..., 0].ravel(),\n                            b_all_diff[..., 1].ravel(),\n                            c=all_diff_int_off.ravel(),\n                            cmap=cmap,\n                            norm=PowerNorm(vmin=0, vmax=1, gamma=0.2))\n\n        # zero order\n        ax_off.plot(b_all_diff[..., 0][zero_order],\n                   b_all_diff[..., 1][zero_order],\n                   \'mx\',\n                   label="0th order")\n\n        # blaze angle out\n        ax_off.plot(b_off_out[:, 0],\n                    b_off_out[:, 1],\n                    \'kx\',\n                    label="blaze")\n\n        ax_off.set_xlabel(\'$b_x$\')\n        ax_off.set_ylabel(\'$b_y$\')\n        ax_off.axis("equal")\n        ax_off.set_xlim([-1, 1])\n        ax_off.set_ylim([-1, 1])\n        ax_off.set_title("\'-\' mirrors\\n"\n                         f"rot axis = ({dmd.rot_axis_off[0]:.3f}, "\n                         f"{dmd.rot_axis_off[1]:.3f}, "\n                         f"{dmd.rot_axis_off[2]:.3f})")\n\n        ax_off.set_xticks(tics)\n        ax_off.set_yticks(tics)\n        ax_off.legend()\n\n        figh.canvas.draw_idle()\n\n    # connect slider moves to function\n    slider_x.on_changed(update)\n    slider_y.on_changed(update)\n    slider_t1.on_changed(update)\n    slider_t2.on_changed(update)\n    slider_phi1.on_changed(update)\n    slider_theta1.on_changed(update)\n    slider_phi2.on_changed(update)\n    slider_theta2.on_changed(update)\n    dm_box.on_submit(update_dm)\n    wlen_box.on_submit(update_wl)\n\n    # call once to ensure displays something\n    update()\n    # block, otherwise will freeze after a short time\n    plt.show(block=True)\n\nprint("This widget simulates the DMD diffraction order intensities\\n"\n      "due the blaze condition for light incident along the unit vector\\n"\n      "($a_x$, $a_y$, $a_z$), which can be adjusted with the sliders.\\n"\n      "Displaying a pattern on the DMD will add additional diffraction orders\\n"\n      "around each primary diffraction order. The wavelength\\n"\n      "and DMD pitch can be adjusted by writing in the text boxes. The DMD mirror\\n"\n      "orientations in the $+$ (on) or $-$ (off) states can be adjusted by changing\\n"\n      "the rotation axis, parameterized by polar angles $\\theta_\\pm, \\phi_\\pm$, and\\n"\n      "the mirror rotation angles $\\gamma_\\pm$\\n")\n\ndmd = sdmd.DLP4710()\ndmd.wavelength = 0.635\n\nwith np.errstate(invalid="ignore"):\n    display_2d(dmd)\n\n'})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:a(4324).A+"",width:"771",height:"595"})})]})}function f(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(_,{...n})}):_(n)}},4324:(n,e,a)=>{a.d(e,{A:()=>t});const t=a.p+"assets/images/nbimage-d374fb2d37356396276ea11f5f483698.png"},8453:(n,e,a)=>{a.d(e,{R:()=>r,x:()=>d});var t=a(6540);const o={},i=t.createContext(o);function r(n){const e=t.useContext(i);return t.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function d(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:r(n.components),t.createElement(i.Provider,{value:e},n.children)}}}]);